Ch03 軟體測試
===

:::success
江 Sir 皺著眉頭，一副憂心忡忡的說：「對不起，我們還不能驗收」。

雄太睜大了眼睛。江 Sir 接著說：「我們前天還發現 bug，這個系統可不出錯阿！」

「可是那是這星期以來唯一的錯誤，事實上，經過我們的內部測試後，交給你們做測試後也沒發現幾個錯誤」

「你敢保證現在沒有錯誤？」

雄太猶豫了一下，說「我敢保證！現在系統沒有任何錯誤了」

江 Sir 冷笑了一下說：「我倒是懂得一點軟體測試的概念，軟體測試只能確保程式有錯，沒有辦法確定程式沒有錯誤！」

雄太一下子楞住了，傻傻的看著江 Sir...
:::

## 軟體測試原則


本節介紹一些軟體測試的原則。

- 窮盡測試是不可行的
- 窮盡測試是不可行的
- 軟體測試是一種風險管理的工作
- 錯誤總是躲在角落，不容易察覺
- 並不是所有的錯誤都會被修復
- 錯了就是有臭蟲，沒錯並不代表沒有臭蟲
- 漸進式的測試
- 殺蟲劑效應
- 即早測試
- 測試是情境相依的
- 測試無法改善品質

:::success
窮盡測試是不可行的
> Exhaustive testing is not possible
:::

<img src="https://hackmd.io/_uploads/HJISXY9ea.png" width=100>

窮盡式的測試式不可能的。簡單的一個程式如下，因為有四個判斷式，每一個判斷式有兩種可能，$2^4=16$ 就有16  可能，一個系統隨隨便便都可能達到100 個判斷式 $2^{100}=1.27*10^{30}$ 是非常大的數字，不可能在有效的時間內進行這樣的測試。


```java
input A, B, X
if (A>1) and (B==0) then Y=A
if (A = 2) or (X>1) then Y = X
print Y 
```

放大一點來看，系統所處的作業系統、用的瀏覽器、周邊非常的多，你很難一一測試; 系統的狀態、資料庫的狀態時時刻刻都在變化，你無法一一測試。所以測試只能「挑著測」，但可不能把重要的漏測了，所以必須要「有效率的測試」。

:::success
軟體測試是一種風險管理的工作
> Software testing is a risk-based exercise
:::

由於我們無法進行窮盡的測試，測試其實無法保證沒有錯的發生，只能提昇其品質的信心。這就像我們進行的風險管理活動：對於大的風險要去預防它，中的風險去減緩它，小的風險則去處理它。


:::success
錯誤總是躲在角落，不容易察覺
> Bugs lurk in corners
:::

考慮以下的程式，第二行的部份應該為 j=j+1, 卻不小心打成 j=j-1:

```java
int scale (int j) {
   j = j - 1; //正確為 j=j+1
   j = j / 3,000;
   return j;
}
```

假設 j 的範圍是 -32,767 到 32,767, 該除法為無條件捨去法，以下幾種狀況會呈現錯誤：

- j = 2,999; 應為 1, 但結果為 0
- j = 3,000; 應為 1, 但結果為 0
- j = 5,999; 應為 2, 但結果為 1
- j = 6,000; 應為 2, 但結果為 1

依此類推，會發生錯誤的情況僅有 18 個\footnote{每3,000會有兩個錯誤}，其餘的情況答案都是一樣的（例如 j=1000, 答案都是 0），所以錯誤發生的機率是 $18/65536 = 0.00027$

可見得相當的低，錯誤是不容易看得到的。錯誤總是躲在角落，所以我們需要進行邊界測試。

:::success
並不是所有的錯誤都會被修復
> Not all the bugs you find will be fixed
:::

當系統大到某一個程度，且盤根錯節的無法知道程式的架構時，修復 bug 可能會帶來更大的 bug，如果bug 所造成的影響是小的，可處理的，這時候我們可能選擇不去除錯。

另外也可能是除錯所需要花費的成本太高，且其發生的機率很低，這時候我們也是有可能不除錯的。例如有一個手機軟體在正常的環境下都是正常運作的，到跑到南北及溫度很低時就會出錯，你會修復這樣的錯誤嗎？公司可能在經濟的考量下決定不修復這樣的錯誤。

:::success
錯了就是有臭蟲，沒錯並不代表沒有臭蟲
> Testing shows presence of defects; testing can't show that the bugs don't exist
:::

當你測試後發現 bug, 那的確就是系統有 bug, 但若測試沒有 bug, 你是無法說系統沒有 bug-- 只是湊巧沒有被測試到罷了。

:::success
漸進式的測試
> Incremental testing
:::

不要等系統都開發好了才進行測試，做一點，測一點。

:::success
殺蟲劑效應
> Pesticide paradox
:::

這叫做殺蟲劑效應。同一種蟑螂藥噴久了以後蟑螂就會產生抗藥性，幾次以後就殺不死蟑螂了。同一群的測試案例用來測試系統，一開始的時候很能找出錯誤，但隨著系統不斷的修正，這一群測試案例就會漸漸的失效，這時候就要重新調整測試案例。

:::success
即早測試
> Early testing
:::

越早測試越好。需求階段發現的小錯誤到設計階段就會逐漸變大，到了上線後錯誤就會變大到非常複雜，甚至難以處理。程式還沒寫好怎麼測試？可以透過規格書審查，設計審查來進行「靜態測試」。

![](https://hackmd.io/_uploads/Hkd4EK5eT.png)


:::success
測試是情境相依的
> Testing is context dependent
:::

在開發環境測試沒有問題，並不能保證在上線環境是沒有問題。主機的硬體設備，作業系統，網路環境等等都可能造成執行的不同。

:::success
測試無法改善品質
> Testing can't improve software quality
:::

正確的說法是無法「直接」改善品質。光只是測試，不做程式碼的修正系統品質當然不會好。擴大來說，一個組織不能只靠測試團隊來提升品質，源頭的設計能力才是關鍵。

## 測試的種類

### 驗證與確認
驗證（Verification）是確定和「規格」寫的是一樣的。確認（Validation）則是確定是「使用者」要的。專案的每個階段都應該進行 V&V, 一方面確定這個階段和規格是相符的，另一方面在確認是使用者要的。

當規格化（需求規格或設計規格）的過程有錯，我們即便做好了 驗證, 最後的產品一樣不是使用者要的，所以應該進行 確認。

以一個除法器系統而言：你的規格上寫的是：除數為 0 時，系統彈出警告訊息，然後離開系統。但程式的寫法是：除數為0 時，系統彈出警告訊息，要求再次輸入。你進行了「驗證」無誤，但還是不是使用者要的，「確認」就錯誤了。

FIG: Verification and Validation

![](https://hackmd.io/_uploads/SJX8EY9e6.png)


### 缺失測試與確認測試
缺失測試（Defect testing）的目的是找出程式的缺失，一個成功的 defect testing 是要能夠發現缺失。為了發現錯誤，我們可能採取任意測試或極端的測試來提昇缺失發生的可能。

確認測試（validation testing）的目的是說明程式能夠符合使用者的需求，成功的 validation testing 是展現使用者的期待的功能都被完整且正確的實作出來。這樣的測試會比較有組織，有規劃，逐步的檢驗所有的功能都是正確的。

### 靜態測試與動態側測試

依測試的方法可以分為靜態測試（static testing）或是動態測試（dynamic testing）。靜態測試指的是不需要程式的執行，只要透過檢視原始碼或是相關的文件來找出錯誤。現在許多的工具可以協助做檢視，但不能完全取代。

動態測試則是透過程式碼的執行，觀察其執行的結果是否符合預期來進行測試。

### 功能測試與結構測試
依測試的目標測試的目標來區分，可以是程式的內部結構是否完成測試（結構測試），或是外在的行為是否符合規格的規範（功能測試）。

圖說明兩者的差別。功能測試的測試案例設計是依據系統的規格來制定的，而結構測試則是依據程式的內在結構來制定的。前者又稱為「黑箱測試」，後者又稱為「白箱測試」。

如果我們只進行結構測試，很可能陷入「程式看起來沒問題卻不是使用者要的窘境」。如果我們只進行功能測試，可能所規範的功能都正確，但對部分系統的行為沒有測試到，到時候真的上線產生嚴重的問題可就糟糕了。所以功能測試與結構測試兩者都必須進行。

FIG: 功能測試與結構測試

![](https://hackmd.io/_uploads/S1FD4Yqla.png)


### 單元測試、整合測試與系統測試

依據顆粒大小可以分為單元測試（unit test），整合測試（integration test）與系統測試（system test）。單元測試針對比較小的模組進行測試，主要在測試程式的邏輯是否正確，整合測試則是測試模組（或單元）之間的介面是否相容。系統測試則是做整體性的測試，檢驗在特定環境下的運作是否正常，是否能夠符合使用上的要求。

雖然我們在切割模組的時候已經做好了介面設計，照理來說系統的整合應該沒有問題，但切割模組時可能會有很多的誤解，如果不好好的進行整合測試，確定雙方的「協定」是一致的，系統就會產生嚴重的錯誤。

![](https://hackmd.io/_uploads/SyMtNK9g6.png)


### 單元模組的可測試性
要把除法寫成一個模組，他的結果回傳給上層處理，不要在裡面直接做介面與邏輯的處理。這樣可以用 JUnit 去測試你的模組，可測會比較好，如果裡面已經是有 UI，你的測試就需要人介入，無法自動化了。

```java
double div(x, y) {
   while (y ==0) {
       // input 是 UI 的行為
       double y = input("除數不可為0, 請重新輸入");
   }
}
```

我們把這個模組的 UI 部分移到外部去，讓 div(x,y) 的功能容易測試：

```java
double div(x, y) throws Exception {
   while (y ==0) {
       throw new Exception("除數不可為0");
   }
}
```

基本的功能模組最好不要有 UI 的介入。這樣外部的方法可以透過自動化的方式來進行測試。

> :smile: 我向程式朋友借了1000，他說再多借你 24 吧，湊個整數


### 其他測試

| 測試種類 | 英文名稱 | 簡易說明 | 測試重點 |
| :--- | :--- | :--- | :--- |
| **模糊測試** | Fuzz Testing | 將大量、無效、非預期或半有效的隨機資料作為輸入，送入程式以檢查軟體的崩潰、異常或安全性漏洞。 | 軟體處理異常或惡意輸入的能力。 |
| **冒煙測試** | Smoke Testing | 在每次新的軟體建構（Build）完成後進行的初步、快速的測試，以確保核心功能和系統的基本穩定性，能「冒煙」運行。 | 核心功能是否能啟動和運作。 |
| **健全性測試** | Sanity Testing | 針對一小部分功能進行的快速測試，通常在修復一個小錯誤或進行小幅變更後執行，以確認該修復或變更沒有影響到相關的功能。 | 特定變更後的邏輯是否健全。 |
| **探索性測試** | Exploratory Testing | 一種同時進行學習、測試設計和測試執行的手動測試方法。測試者在沒有詳細測試計畫的情況下，主動探索軟體以發現缺陷。 | 測試者的經驗、創造力，以及發掘隱藏缺陷的能力。 |
| **Alpha 測試** | Alpha Testing | 軟體在公司內部或開發者控制的環境下進行的模擬營運測試，通常在 Beta 測試前進行。 | 系統的內部穩定性和功能是否完善。 |
| **Beta 測試** | Beta Testing | 軟體發布前的公開或有限度公開測試，由真實的外部使用者在實際環境中進行，用於發現使用者情境下的缺陷。 | 軟體在真實世界中的相容性和可用性。 |
| **相容性測試** | Compatibility Testing | 測試軟體在不同硬體、作業系統、網路環境、瀏覽器或裝置等組合下的運作狀況。 | 軟體的跨平台和跨環境能力。 |
| **負載測試** | Load Testing | 屬於性能測試的一種，旨在確定在預期的大量使用者或資料處理下，系統的行為和反應時間。 | 系統在高負載下的表現。 |
| **可擴展性測試** | Scalability Testing | 測試系統在增加負載時，能否透過增加硬體或資源來維持或提高性能的能力。 | 系統的成長和擴展能力。 |
| **可維護性測試** | Maintainability Testing | 評估軟體在修復缺陷、進行變更或增加新功能時的容易程度。 | 程式碼結構和設計的清晰度。 |

---

這些測試種類可以從不同維度（如測試時機、執行方式、測試深度）來涵蓋軟體品質的各個層面。

## V 開發模型

![V model](https://hackmd.io/_uploads/SyGoNt5lp.png)

V 開發模型是一個結合系統開發與測試的模型，代表著不同階段的開發重點與測試重點。如 圖\ref{img_V_model}，系統開發包含：


- 需求分析（requirement analysis）產生 SRS（Software Requirement Specification; SRS）與系統測試計畫（System test plan）;
- 高階設計（high-level design）包含架構的設計，產生架構設計文件（Architecture Design Document; ADD）與整合測試計畫;
- 細部設計（detail design）產生系統設計文件（System Design Document; SDD）與單元測試計畫（或單元測試設計）;
- 接著進行系統實作（implementation）。

等待系統實作完畢後，接著進行單元測試（unit testing），整合測試（integration testing）與系統測試（system testing）。單元測試必須依據 SDD 來進行測試案例的設計; 整合測試必須依據 ADD 來設計測試案例，因為 ADD 內會描述各子系統或模組的介面，這正是整合測試所需要的資訊。系統測試時會依據 SRS 的規格要求來制定測試案例，因為這時候的測試必須檢驗是否符合使用者所需要的功能。

V model 和 waterfall 很像，但注意到了嗎？它除了產生規格書、設計書以外也同時要規劃系統測試計畫與整合測試計畫，這樣的好處在於，*測試設計並不是到了測試時才開始準備，而是在需求定義（或設計階段）就開始了}，這樣比較公正，不會被後續的開發所干擾。

> *實作後的測試偏差* 實作後再編寫的測試案例會受實作過程的影響，無法有效的確認測試。

> :question: 應用 V model 說明 日本創意、台灣設計、印度開發的可能性合作關係

## 測試案例
測試案例的完整性，和需求規格，程式的行為的關聯性。

- 規劃的行為（specified behavior）：規格書裡面所規劃的需求或期待系統所表現出的行為。
- 程序化的行為（programmed behavior）：最後真的被寫出來的系統，所表現出來的行為。理想上當然*規劃的行為}應該和*程序化的行為}應該是相等的，但實際上兩者常常會有所不同，甚至差距很大，
- 驗證的行為（verified behavior）：系統在測試時所表現出的行為。你的測試可能無效的，沒有測到規格書的內容或是程式的行為。當然，我們期待驗證的行為能和前面兩個能夠重疊，這樣最好。

FIG: 測試案例與規格，程式行為的關係

![](https://hackmd.io/_uploads/rJeyNHK9e6.png)


> :question: 說說看圖形各區代表的意義為何，特別是 5, 6, 7

幾個區域的說明：
- 2+1: 規劃的功能且有被實作出來
- 1+4: 規劃的功能且有被測試到的部分
- 1+3: 開發出的系統且有被測試到的
- 1: 規劃要開發，且有被開發實作出來，且有被測試到。我們當然期待這部份是很大的，代表著專案的開發符合需求，測試也很有效。

當 1+4 大於 1+3 通常表示所進行的是黑箱測試，反之則是白箱測試。

> 你想的，我寫的，他測的，常常搭不在一塊。

### 測試設計與測試資料

測試案例（Test case）: 測試的規劃，用來展示測試的完成度與包含度; 引導測試資料的設計。測試資料（Test data）: 明確的測試資料，可以讓程式執行來觀察是否正確。

除法的例子：在規劃階段我們會考慮以下幾種案例

```java
分母 = 0
分母 != 0
  整除
  不整除
     進位
      不進位
```

依據這樣的測試案例，我們會規劃這樣的測試資料：(假設我們的需求是四捨五入求整數。*表示測試資料）

```
分母 = 0, (5,0) => 錯誤
分母 != 0
  整除, (4,2) => 2
  不整除
     進位, (5.1, 3) => 2
     不進位, (4,3)  => 1.3
```

> 測試案例 = [輸入, 預期輸出]

如果我們不寫測試案例只是寫測試資料，這樣的測試設計缺乏設計的完整性說明（或涵蓋度說明），很難驗證測試設計的好壞。

:question: 設計「判斷是何種三角形」的程式的「測試案例」與「測試資料」。輸入是三邊長，型態為 double, 輸出是字串。例如輸入 1,1,1 輸出為 正三角形。

#### 測試程序

有時候測試案例是包含程序或是互動的。例如除法器的規格：「若除數為零，則要求重新輸入，但若連續超過三次則跳出」。此時我們要設計資料的輸入次序為：12/0, 11/0, 10/0。

又有時我們測試一筆資料後，需要把測試資料清空才能進行下一個測試，這時候也要在測試程序中說明。

> 設計測試案例時，**預期結果**是很重要的，可能是一個數值、字串、資料的更新、畫面的呈現、現象。不論是什麼，都該具體而清楚的描述。

FIG: 測試流程

![](https://hackmd.io/_uploads/SkHLHKcg6.png)


## 3W2H

以下從五個角度來分類：who? what? why? how? how to evaluate? 

FIG: 測試的種類
![](https://hackmd.io/_uploads/SyDwSFql6.png)


### 面向一：Who 誰測試？

- 工程師測試。開發工程師對自己的程式必須進行單元測試。
- 測試團隊。公司內部對軟體進行測試，Alpha testing。
- 開發夥伴。在 pair programming 中，一個工程師負責寫程式，一個工程師負責進行測試。
- 業務單位。由熟悉業務規則的業務單位針對系統是否符合業務規則進行測試。
- 專家測試。該領域專家的測試。
- 小眾使用者。Beta testing，一群使用者所進行的小眾測試。測試者不可是開發團隊或組織的人員。
- 路人甲。由不熟習此領域或專案的人來進行測試，有時候更能跳脫固有思維，找到錯誤。
- 驗收人員。進行驗收測試。

### 面向二：What 測什麼？

測試的對象是什麼？主要考量我們測試是希望包含哪些對象或標的物，例如所有的功能、狀態、選單等。這會和「包含度」有關，我們的測試想包含所有的什麼東西？

- 功能測試。測試包含所有列舉的功能，又可分為規格測試、領域規則測試、等價測試、輸入欄位測試、選單測試等。我們將在黑箱測試一章中說明。
	
	- 規格測試。規格包含所有宣告在規格書，手冊，市場行銷文件廣告文件等功能。
	- 等價測試。測試等價分割後的群組。測試資料會先被分類成不同的群組，測試時從不同的群組至少找一個資料來測試。測試案例是等價的如果 (1) 他們是相同的事情 (2) 如果一個可以找到錯誤，其他的也可以 (3) 如果其中一個無法找到錯誤，其他的應該也找不到錯誤。
	- 邊界測試。測試等價類別的邊界值。
	- 輸入欄位測試。系統中會有一些不同意義或格式的資料輸入欄位，例如電話輸入、主旨輸入、生日等欄位。針對每一種類型設計可能的輸入值，例如 (02) 1234-567, 0911-213908, +886-911213919 等。	
	
- 結構測試：測試程式的結構，包含基本路徑測試、敘述與分支測試、邏輯測試等，我們將在白箱測試一章中特別說明。

- 行為測試：包含狀態測試、情境測試、輸入欄位方法等測試。輸入欄位方式測試：同一個欄位可能有很多輸入的方式，例如匯入，直接輸入，複製等，針對這些可能的輸入方式進行測試。欄位輸入的時候可能會有限制（例如必須大於零），要注意違反這些限制時系統的反應。

- 整體系統：亦即系統測試，系統測試包含構型測試、負載測試、耐力測試、效能測試 、安裝測試、安全測試、可靠度測試等。

#### 情境測試 Scenario testing

依據系統的操作情境來進行測試，此測試有一些特點：(1) 真實的，反應顧客真的想做的事; (2) 複雜的，包含很多的特性; (3) 容易且快速的，顧客可以很容易的決定通過與否，因為該情境是它所熟悉的; (4) 重要的，與系統可否上線正式服務有很大的關係。

> :question: F 大有一個教學系統，裡面會記錄學生各式各樣的成績（點名，專案，作業，討論，期中，期末），但送交學校校務系統僅記錄三個成績：平時、期中與期末。從教學系統到校務系統成績的登錄可能有幾種方式？

### 面向三：Why 為何測試？

測試的動機也很重要，我們為什麼進行測試？

- 針對高風險（高機率，高影響力）的測試案例進行測試，例如變更風險、專案風險、需求風險、技術風險等。(1) 變更風險：New and change risk: 新的技術，新的系統，新的市場等都很有可能造成系統的失敗。(2) 專案風險：糟糕的專案管理也會造成我們對系統的不信任：倉促的工作時程，糟糕的設計，無法維護的實作，累翻的程設工程師，員工的問題，經費的問題。 (3)  需求風險：需求工程的失敗是專案失敗最大的元兇：模糊的需求，衝突的需求，未知的需求，不穩定的需求。(4) 測試風險：測試很複雜，測試常出錯，相依性太高，可測試性太差，單元測試太少，到目前為止太少測試，測試工具功能太弱等。
- 功能可靠度測試：錯誤的類別可能來自於違反一些限制，測試的目的是要檢查這些限制是否系統都有妥善的處理（例外處理，防呆處理）：
	
	- 不符合輸入限制（input constraint）。
	- 不符合輸出限制（output constraint）。雖然符合輸入是通過的，但經過計算後的結果卻不符合，例如數值太大，精準度太高等，輸出的介面無法表把。
	- 不符合計算的限制（computation constraint）。例如超過超過記憶體的用量。
	- 不符合空間的限制（storage constraint）。超過儲存空間的限制。
	- Beta 測試：確認在非開發環境是可行的。
- 整合測試：確保介面溝通正確。
- 系統測試：確保整體系統運作正常。
- 驗收測試：使用者確認。
- 回歸測試：修改後是否正常。

| Alpha testing                          | Beta testing                            |
| -------------------------------------- | --------------------------------------- |
| 通常在開發端執行測試                 | 通常在客戶端執行測試                  |
| 內部測試不公開                       | 局部公開給外部人進行測試            |
| 通常在虛擬環境（測試環境）測試   | 通常在正式環境測試                    |
| 通常使用非正式資料                   | 通常使用顧客的正式資料                |
| 通常採用黑箱測試與白箱測試混合的方式 | 通常採用黑箱測試                      |


#### 回歸測試 Regression test

檢驗之前所開發並測試過的軟體，在經過修改後仍然運作正確。回歸測試通常有幾種做法：

- retest all: 將之前的測試案例整個重新執行，這一類的測試成本會比較高。
- regression test selection: 選擇部分的測試案例來進行測試，例如選擇會經過修改或被影響的程式碼的測試案例。
- test case prioritization: 將測試案例依其重要性排序，較重要的測試案例先進行測試。


### 面向四：How 如何測試？

這個角度著重在如何進行測試。

- 隨機測試：沒有特別系統化的方式，隨機的檢驗系統是否運作正常。
- Monkey test：通常是由程式產生隨機的資料進行測試，檢查系統是否運作正常。
- 人工測試：由人工的方式操作系統來進行測試。
- 腳本測試 (Scripted testing)：測試員依據測試設計師所規劃的測試草本一步步的進行測試。測試員不用花腦筋去了解企業邏輯，測試應該如何設計，測試的流程應該如何比較好，只要依據草本逐步的進行測試即可。腳本亦可透過程式化的過程來達到自動化測試。
- 探索測試（exploratory testing）：有別於腳本測試，測試者能夠在測試中逐步的了解系統特性，自發性的設計更多測試案例來進行測試，了解越多測試案例越有效。 探索測試就像是在玩 20 questions 一樣，一開始的問題是很模糊的，但逐漸聚焦，能夠問到問題的中心，就像能夠測試到真正重要的功能一般。
- Record and replay。透過錄製使用行為來產生測試腳本，在進行測試。
- 回歸測試：以過去的測試案例進行測試。
- 自動化程式測試：特別撰寫程式來測試系統。
- 游擊隊測試：快速且劇烈的攻擊此系統，檢驗系統在負荷及安全性上是否可以支撐。
- 工具測試：透過工具來產生測試案例，或進行測試。


FIG: Monkey Test
![](https://hackmd.io/_uploads/r1OoBt5ga.png)


FIG: Record and replay
![](https://hackmd.io/_uploads/Skw3SK5xT.png)

FIG: Exploring Test
![](https://hackmd.io/_uploads/SkNTHK9ea.png)



### 面向五：How 如何決定通過？

- 自我檢驗：由測試者自行判斷是否通過，依據一些事先規劃的資料檔案。
- 與預定結果：通常用在測試先行的方法，預期的結果（expected result）已經事先被儲存了，所以可以透過自動化測試的方式來做檢視。
- 涵蓋度：依據受測系統的測試涵蓋度，例如指令涵蓋度（statement coverage）、條件涵蓋度（branch coverage）、需求涵蓋度（requirements coverage）等作為通過與否的基準。
- 錯誤率：當錯誤率低於某個程度即可通過。
- 與規格書比較：依據規格書或是其他受認證的文件。
- 回歸測試：回歸測試是指過去已通過測試，但系統修改後需要再次的測試，如果程式的規格不變，僅有設計或實作改變，這時候過去的測試碼或測試案例就可以拿來重用。
- 啟發式評估：檢驗可能依據一些標準、原則或是檢查的項目。例如以下是一個啟發式「一致性 consistency」的檢核：
	- 與過去的使用經驗一致 
	- 與相似的產品一致
	- 與宣稱的功能一致
	- 與使用者的期望一致 
	- 與整個產品的風格一致  
	- 與系統的目的一致
	- 變異測試：用來檢驗你的測試案例是否足夠。此方法不是測試受測系統，而是測試「測試案例」是否足夠。	


FIG: Coverage report
![](https://hackmd.io/_uploads/B1aCSY5lp.png)

#### Oracle based testing
Oracle 是神蹟的意思，在軟體測試的領域中代表「可以判斷程式是否正確的工具或程式模組」(註：因為這工作很難，能夠判斷簡直是神蹟）。例如某搜尋軟體號稱可以找出「網路上最多被引用美食網站」，你如何驗證他是對的？又某一個工具算出 $sin(28.9)$, 你又如何知道他在小數點下兩位的值是對的？這可能需要一個特別的程式來進行測試，而不是很快的可以觀察出來或是說明的。

測試的驗證有許多技巧，例如我們依據以下的公式來計算 $sin(x)$ 的值，但卻不知道有沒有算錯（如果不能查表的話）。

$sin(x) = x - (x^3/3!) + (x^5/5!) - (x^7/7!) + ...$

但我們知道他有以下的特性

$sin(x) = sin(-x) = cos(90-x)$


## ✍️ 練習


### 測試原則

- 以下何者正確？	
	- 為了確保程式的正確性，我們必須進行窮盡式的測試（exhaustive testing）
	- 當我們發現很多 bug並解除這些 bug 後,  該處仍可能有很多的 bug, 需要再仔細的測試。
	- 測試只能說明有錯誤的存在，沒有辦法說明沒有錯誤。
	- 測試必須等到程式開發完後才能進行，是軟體開發最後的階段的重要工作。
- 以下何者正確？
	- 我們所規劃的功能（specified function）與開發出的功能（programmed function）通常會有差異。如果我們依前者來設計測試案例，是屬於 function test; 依據後者來設計測試案例則稱為 structure test。
	- function test 又稱為  black-box test。Structure test 又稱為 white box test
	- 系統測試是針對整個系統的所有模組進行測試，又稱為整合測試。
	- 所謂回歸測試（regression test）是指針對統計的迴歸分析（regression analysis）進行仔細的測試。
- 何謂軟體測試的「殺蟲劑現象」？

### V 模型

- 依據 V 模型，需求規格書確定後，應該設計哪一個測試計畫？
	- 單元測試計畫 
	- 整合測試計畫 
	- 回歸測試計畫 
	- 系統測試計畫 
	- 回歸測試
- JUnit 可以設計測試案例與資料，它是在哪個階段後開始設計？
	- 系統規格完成 
	- 架構設計完成 
	- 模組設計完成 
	- 模組實作完成 
	- 回歸設計完成
- 畫出 V 模型
- 比較 V 模型與瀑布模型

### 測試案例
- 針對以下功能，設計測試案例與測試資料
	
	- 計算最大公因數 `int getLCM(int x, int y);`
	- 計算 `double sin(double x)`
	- 取最大值 `int getMax(int data[])`
	- 排序 `int[] sort(int data[])`	
	
- 針對以下系統，其測試設計的重點為何？其測試的困難點為何？
	- Shoppint Mall 購物系統	
	- 選課系統
	- 線上考試系統
	- 人工智慧圍棋系統

### 測試種類

- 比較以下的差異：(1) Verification vs. validation (2) static testing vs. dynamic testing (3) alpha testing vs. beta testing.
- 測試可以從不同的角度來分類，試說明之
- 如果我只有系統的功能規格，我應該進行黑箱測試或是白箱測試？
- 有哪些方式可以判斷測試是否通過？
- Scripted testing 和 exploratory testing 有何差異？
- Scenario testing 有何特性？
- 變異測試（Mutation test）的目的並不是檢驗系統是否通過測試，其目的為何？

### 綜合

- 以下測試屬於系統測試、整合測試、或是單元測試: 
	
	- 加密的方法是否正確
	- 系統回應的速度是否太慢
	- 兩個異質的系統透過 XML 傳遞訊息後功能是否正常
	- 系統的備援機制是否正常
	- 不正常的資料進入該模組參數後，運作是否正常
	
- 某個網頁系統需要先經過申請才能開始使用，申請時需要填入帳號，email，電話，國籍與城市。請設計測試案例，並說明你的設計策略為何？

- 在一個象棋系統中，一個棋子從 (x,y) 移動到 (z,w)，請描述你的測試案例，與測試資料。

- 在一個考試系統中，你可能會進行哪些單元測試？哪些整合測試？哪些系統測試？

- 有一個判斷三角形的程式 check(x, y, z) 檢查是否為合格的三角形，為了簡化程式設計，雙方（模組開發者與呼叫者）互訂 x<=y<=z。哪個測試階段需要注意這個問題？

- 舉例說明三個軟體系統是很難測試的？並發揮創意說明你的測試方法。

> :smile: 軟體就像做愛。一次犯錯，你需要用剩下的一生來彌補
>> Programming is like sex. One mistake and you have to support it for the rest of your life. (Michael Sinz)